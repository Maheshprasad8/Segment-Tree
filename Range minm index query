You are given a 0-indexed array heights of positive integers, where heights[i] represents the height of the ith building.

If a person is in building i, they can move to any other building j if and only if i < j and heights[i] < heights[j].

You are also given another array queries where queries[i] = [ai, bi]. On the ith query, Alice is in building ai while Bob is in building bi.

Return an array ans where ans[i] is the index of the leftmost building where Alice and Bob can meet on the ith query. If Alice and Bob cannot move to a common building on query i, set ans[i] to -1.


Example 1:

Input: heights = [6,4,8,5,2,7], queries = [[0,1],[0,3],[2,4],[3,4],[2,2]]
Output: [2,5,-1,5,2]


................................Solved by Segment Tree [RMIQ]....................
class Solution {
public:
    int querySegment(int start, int end, int i, int l, int r, int st[],
                     vector<int>& heights) {
        if (l > end || r < start) {
            return -1; // invailid
        }
        if (l >= start && r <= end) {
            return st[i];
        }
        int mid = l + (r - l) / 2;
        int leftIndex =
            querySegment(start, end, 2 * i + 1, l, mid, st, heights);
        int rightIndex =
            querySegment(start, end, 2 * i + 2, mid + 1, r, st, heights);
        if (leftIndex == -1) {
            return rightIndex;
        }
        if (rightIndex == -1) {
            return leftIndex;
        }
        return (heights[leftIndex] >= heights[rightIndex]) ? leftIndex
                                                         : rightIndex;
    }
    int RMIQ(int st[], vector<int>& heights, int n, int a, int b) {
        return querySegment(a, b, 0, 0, n - 1, st, heights);
    }
    void buildSegmentTree(int i, int l, int r, int* segmentTree,
                          vector<int>& heights) {
        if (l == r) {
            segmentTree[i] = l;
            return;
        }
        int mid = l + (r - l) / 2;
        buildSegmentTree(2 * i + 1, l, mid, segmentTree, heights);
        buildSegmentTree(2 * i + 2, mid + 1, r, segmentTree, heights);
        int leftIdx = segmentTree[2 * i + 1];
        int rightIdx = segmentTree[2 * i + 2];
        segmentTree[i] =
            (heights[leftIdx] >= heights[rightIdx]) ? leftIdx : rightIdx;
    }
    int* constructST(vector<int>& heights, int n) {
        int* segmentTree = new int[4 * n];
        buildSegmentTree(0, 0, n - 1, segmentTree, heights);
        return segmentTree;
    }
    vector<int> leftmostBuildingQueries(vector<int>& heights,
                                        vector<vector<int>>& queries) {
        int n = heights.size();
        int* segmentTree = constructST(heights, n);
        vector<int> result;
        for (auto& query : queries) {
            int min_idx = min(query[0], query[1]);
            int max_idx = max(query[0], query[1]);
            if (min_idx == max_idx) {
                result.push_back(min_idx);
                continue;
            } else if (heights[max_idx] > heights[min_idx]) {
                result.push_back(max_idx);
                continue;
            }
            int l = max_idx + 1;
            int r = n - 1;
            int res_idx = INT_MAX;
            while (l <= r) {
                int mid = l + (r - l) / 2;
                // return max element ka index in range l,mid
                int idx = RMIQ(segmentTree, heights, n, l, mid);
                if (heights[idx] > max(heights[max_idx], heights[min_idx])) {
                    res_idx = min(res_idx, idx);
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            }
            if (res_idx == INT_MAX) {
                result.push_back(-1);
            } else {
                result.push_back(res_idx);
            }
        }
        return result;
    }
};
